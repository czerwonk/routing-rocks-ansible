function is_bogon() {
  if bgp_path ~ BOGON_ASNS then {
    return true;
  }

  return net ~ [
    10.0.0.0/8{8,32},
    172.16.0.0/12{8,32},
    192.168.0.0/16{16,32},
    169.254.0.0/16{16,32},
    224.0.0.0/3{3,32},
    100.64.0.0/10{10,32},
    0.0.0.0/8{8,32},
    127.0.0.0/8{8,32},
    192.0.0.0/24{24,32},
    198.18.0.0/15{15,32},
    198.51.100.0/24{24,32},
    203.0.113.0/24{24,32},
    240.0.0.0/4{4,32},
    255.255.255.255/32
  ];
}

function is_default_route() {
  return net = 0.0.0.0/0;
}

function is_own_prefix() {
{% for p in prefixes.ipv4 | default([]) %}
  if net = {{ p.prefix }} then return true;
{% endfor %}
  return false;
}

filter drain {
  reject;
}

filter accept_all {
  if DRAINED = 1 then reject;
  accept;
}

filter full_view {
  if DRAINED = 1 then reject;
  if is_bogon() then reject;
  if is_default_route() then reject;
  
  if net ~ [ 0.0.0.0/0{0,24} ] then {
    accept;
  }

  reject;
}

filter ibgp_in {
  if DRAINED = 1 then reject;
  if net ~ [ {{ ibgp_ipv4_prefix_filter }} ] then accept;
  reject;
}

filter ibgp_out {
  if DRAINED = 1 then reject;
  if is_default_route() then accept;
  reject;
}

function should_announce_ebgp() {
  if is_own_prefix() then {
    tag_origin();
    return true; 
  }

  if is_downstream_route() then {
    return true;
  }

  return false;
}

filter ebgp_out {
  if DRAINED = 1 then reject;

  if (should_announce_ebgp()) then {
{% for i in range(path_prepend | default(0)) %}
    bgp_path.prepend({{ asn }});
{% endfor %}
    accept;
  }

  reject;
}

filter ebgp_out_failsafe {
  if DRAINED = 1 then reject;

  if (should_announce_ebgp()) then {
{% for i in range(path_prepend | default(0) + 3) %}
    bgp_path.prepend({{ asn }});
{% endfor %}

    accept;
  }
  
  reject;
}

filter upstream_in {
  if DRAINED = 1 then reject;
  if is_default_route() then reject;
  if is_bogon() then reject;
  if is_own_prefix() then reject;
  if is_tagged_with_own_community() then reject;

  tag_upstream();

  accept;
}

{% for peer in peerings.ipv6 | default([]) %}
{% if peer.accepted_prefixes is defined %}
filter peer_as{{ peer.asn }}_in {
  if DRAINED = 1 then reject;
  if is_tagged_with_own_community() then reject;

{% for p in peer.accepted_prefixes %}
  if net ~ [ {{ p }} ] then {
    tag_peering();
{% if peer.downstream | default(false) %}
    tag_downstream();
{% endif %}
    accept;
  }
{% endfor %}

  reject;
}

{% endif %}
{% endfor %}
filter bb_ibgp_in {
  if DRAINED = 1 then reject;

{% for prefix in prefixes.ipv4 | default([]) %}
  if net ~ [ {{ prefix }}{8,24} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter site_ibgp_out {
  if DRAINED = 1 then reject;

{% for prefix in prefixes.ipv4 | default([]) %}
  if (source = RTS_STATIC || source = RTS_DEVICE) && net ~ [ {{ prefix }}{24,24} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter bb_ibgp_out {
  if DRAINED = 1 then reject;

{% for prefix in prefixes.ipv4 | default([]) %}
  if source = RTS_STATIC && net ~ [ {{ prefix }}{8,24} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter bb_ibgp_full_out {
  if is_default_route() then reject;
  
  if net ~ [ 0.0.0.0/0{0,24} ] then {
    accept;
  }

{% for prefix in prefixes.ipv4 | default([]) %}
  if (source = RTS_STATIC || source = RTS_DEVICE) && net ~ [ {{ prefix }}{8,24} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter bb_ibgp_failsafe_in {
  if is_default_route() then reject;
  if is_bogon() then reject;
  if is_own_prefix() then reject;

  if is_peer_route() then {
    bgp_local_pref = 1000;
  }
  else {
    bgp_local_pref = 5;
  }

  accept;
}

filter ospf_out {
{% for prefix in prefixes.ipv4 | default([]) %}
  if source = RTS_DEVICE && net ~ [ {{ prefix }}{32,32} ] then {
    accept;
  }
{% endfor %}

  if source = RTS_STATIC && is_default_route() && DRAINED = 0 then {
    accept;
  }

  reject;
}

filter ospf_in {
{% for prefix in prefixes.ipv4 | default([]) %}
  if net ~ [ 0.0.0.0/0{32,32} ] then {
    accept;
  }
{% endfor %}

  reject;
}
