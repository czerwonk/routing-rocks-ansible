function is_bogon() {
  if is_bogon_asn() then {
    return true;
  }

  return net ~ [
    10.0.0.0/8{8,32},
    172.16.0.0/12{8,32},
    192.168.0.0/16{16,32},
    169.254.0.0/16{16,32},
    224.0.0.0/3{3,32},
    100.64.0.0/10{10,32},
    0.0.0.0/8{8,32},
    127.0.0.0/8{8,32},
    192.0.0.0/24{24,32},
    198.18.0.0/15{15,32},
    198.51.100.0/24{24,32},
    203.0.113.0/24{24,32},
    240.0.0.0/4{4,32},
    255.255.255.255/32,
    ::/128,
    ::1/128,
    fc00::/7{7,128},
    fe80::/10{10,128},
    2001::/32{32,128},
    2001:0002::/48{48,128},
    2001:0010::/28{28,128},
    2002::/16{16,128},
    2001:db8::/32{32,128},
    ff00::/8{8,128},
    3ffe::/16{16,128}
  ];
}

function is_default_route() {
  return net = 0.0.0.0/0 || net = ::/0;
}

function is_own_prefix() {
{% for p in prefixes.ipv4 | default([]) %}
  if net = {{ p }} then return true;
{% endfor %}
{% for p in prefixes.ipv6 | default([]) %}
  if net = {{ p }} then return true;
{% endfor %}
  return false;
}

function is_rtbh() {
{% for p in prefixes.ipv4 | default([]) %}
  if net ~ [ {{ p }}{32,32} ] && gw = 192.168.2.1 then return true;
{% endfor %}
  return false;
}

filter drain {
  reject;
}

filter accept_all {
  if DRAINED then reject;
  accept;
}

filter full_view {
  if DRAINED then reject;
  if is_bogon() then reject;
  if is_default_route() then reject;
  
  if net ~ [ 0.0.0.0/0{0,24}, ::/0{0,48} ] then {
    accept;
  }

  reject;
}

function should_announce_ebgp() {
  if is_own_prefix() then {
    tag_origin();
    return true; 
  }

  if is_downstream_route() then {
    return true;
  }

  return false;
}

function default_ebgp_out() {
  if DRAINED then {
    return false;
  }

  if should_announce_ebgp() then {
{% for i in range(path_prepend | default(0)) %}
    bgp_path.prepend({{ asn }});
{% endfor %}
    return true;
  }

  return false;
}

{% for peer in peerings | default([]) %}
{% if peer.asn != asn %}
filter ebgp_as{{ peer.asn }}_out {
{% if peers[peer.asn].rtbh_community is defined %}
  if is_rtbh() then {
    bgp_community.add(peers[peer.asn].rtbh_community);
    accept;
  }

{% endif %}
  if default_ebgp_out() then {
{% for i in range(peers[peer.asn].as_prepend | default(peer.as_prepend) | default(0)) %}
    bgp_path.prepend({{ asn }});
{% endfor %}
{% for c in peer.communities | default(peers[peer.asn].communities) | default([]) %}
    bgp_community.add({{ c }});
{% endfor %} 
{% for c in peer.large_communities | default(peers[peer.asn].large_communities) | default([]) %}
    bgp_large_community.add({{ c }});
{% endfor %} 
    accept;
  }

  reject;
}

{% endif %}
{% endfor %}
{% for peer in peerings | default([]) %}
{% if peers[peer.asn].upstream | default(false) %}
filter upstream_as{{ peer.asn }}_in {
  if DRAINED then reject;
  if is_bogon() then reject;
  if is_own_prefix() then reject;
  if is_tagged_with_own_community() then reject;

  tag_upstream();

{% for r in peers[peer.asn].rules | default([]) %}
{% if r.when.source_as is defined %}
  if bgp_path.last = {{ r.when.source_as }}{% if r.ip_version is defined %} && net.type = NET_IP{{ r.ip_version }}{% endif %} then {
{% elif r.when.prefix is defined %}
  if net ~ [ {{ r.when.prefix }} ] then {
{% elif r.when.community is defined %}
  if bgp_community ~ {{ r.when.community }} then {
{% elif r.when.large_community is defined %}
  if bgp_large_community ~ {{ r.when.large_community }} then {
{% endif %}
{% if r.then.set_local_pref is defined %}
    bgp_local_pref = {{ r.then.set_local_pref }};
{% elif r.then.add_community is defined %}
    bgp_community.add({{ r.then.add_community }});
{% elif r.then.add_large_community is defined %}
    bgp_large_community.add({{ r.then.add_large_community }});
{% endif %}
  }

{% endfor %}
  accept;
}

{% endif %}
{% endfor %}
{% for peer in peerings | default([]) %}
{% if peers[peer.asn].as_set is defined %}
filter peer_as{{ peer.asn }}_in {
  if DRAINED then reject;
  if is_bogon() then reject;
  if is_own_prefix() then reject;
  if is_tagged_with_own_community() then reject;

  if net ~ {{ peers[peer.asn].as_set }}_IPv4 || net ~ {{ peers[peer.asn].as_set }}_IPv6 then {
    tag_peering();
{% if peers[peer.asn].downstream | default(false) %}
    tag_downstream();
{% endif %}
{% for r in peers[peer.asn].rules | default([]) %}

{% if r.when.source_as is defined %}
    if bgp_path.last = {{ r.when.source_as }}{% if r.ip_version is defined %} && net.type = NET_IP{{ r.ip_version }}{% endif %} then {
{% elif r.when.prefix is defined %}
    if net ~ [ {{ r.when.prefix }} ] then {
{% elif r.when.community is defined %}
    if bgp_community ~ {{ r.when.community }} then {
{% elif r.when.large_community is defined %}
    if bgp_large_community ~ {{ r.when.large_community }} then {
{% endif %}
{% if r.then.set_local_pref is defined %}
      bgp_local_pref = {{ r.then.set_local_pref }};
{% elif r.then.add_community is defined %}
      bgp_community.add({{ r.then.add_community }});
{% elif r.then.add_large_community is defined %}
      bgp_large_community.add({{ r.then.add_large_community }});
{% endif %}
    }
{% endfor %}
    accept;
  }

  reject;
}

{% endif %}
{% endfor %}
filter bb_ibgp_in {
  if DRAINED then reject;

{% for p in prefixes.ipv4 | default([]) %}
  if net ~ [ {{ p }}{8,24} ] then {
    accept;
  }
{% endfor %}
{% for p in prefixes.ipv6 | default([]) %}
  if net ~ [ {{ p }}{52,64} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter site_ibgp_out {
  if DRAINED then reject;

{% for p in prefixes.ipv4 | default([]) %}
  if (source = RTS_STATIC || source = RTS_DEVICE) && net ~ [ {{ p }}{24,24} ] then {
    accept;
  }
{% endfor %}
{% for p in prefixes.ipv6 | default([]) %}
  if (source = RTS_STATIC || source = RTS_DEVICE) && net ~ [ {{ p }}{64,64} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter bb_ibgp_out {
  if DRAINED then reject;

{% for p in prefixes.ipv4 | default([]) %}
  if source = RTS_STATIC && net ~ [ {{ p }}{8,24} ] then {
    accept;
  }
{% endfor %}
{% for p in prefixes.ipv6 | default([]) %}
  if source = RTS_STATIC && net ~ [ {{ p }}{52,64} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter bb_ibgp_full_out {
  if is_default_route() then reject;
  
  if net ~ [ 0.0.0.0/0{0,24}, ::/0{0,48} ] then {
    accept;
  }

{% for p in prefixes.ipv4 | default([]) %}
  if (source = RTS_STATIC || source = RTS_DEVICE) && net ~ [ {{ p }}{8,24} ] then {
    accept;
  }
{% endfor %}
{% for p in prefixes.ipv4 | default([]) %}
  if (source = RTS_STATIC || source = RTS_DEVICE) && net ~ [ {{ p }}{52,64} ] then {
    accept;
  }
{% endfor %}

  reject;
}

filter bb_ibgp_local_router_in {
  if is_default_route() then reject;
  if is_bogon() then reject;
  if is_own_prefix() then reject;

  if is_peer_route() then {
    bgp_local_pref = 1000;
  }
  else {
    bgp_local_pref = 5;
  }

  accept;
}

filter ospf_out {
{% for p in prefixes.ipv4 | default([]) %}
  if source = RTS_DEVICE && net ~ [ {{ p }}{32,32} ] then {
    accept;
  }
{% endfor %}
{% for p in prefixes.ipv6 | default([]) %}
  if source = RTS_DEVICE && net ~ [ {{ p }}{128,128} ] then {
    accept;
  }
{% endfor %}

  if source = RTS_STATIC && is_default_route() && !DRAINED then {
    accept;
  }

  reject;
}

filter ospf_in {
{% for p in prefixes.ipv4 | default([]) %}
  if net ~ [ {{ p }}{32,32} ] then {
    accept;
  }
{% endfor %}
{% for p in prefixes.ipv6 | default([]) %}
  if net ~ [ {{ p }}{128,128} ] then {
    accept;
  }
{% endfor %}

  reject;
}
{% for filter in filters | default([]) %}

filter {{ filter.name }} {
  if DRAINED then reject;
{% for p in filter.prefixes | default([]) %}
  if net ~ [ {{ p }} ] then accept;
{% endfor %}
{% if filter.accept_default | default(false) %}
  if is_default_route() then accept;
{% endif %}
  reject;
}
{% endfor %}
